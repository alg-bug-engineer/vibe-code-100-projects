import { supabase } from './supabase';
import type { Profile, Item, ItemType, TagStats } from '@/types/types';

export const profileApi = {
  async getCurrentProfile(): Promise<Profile | null> {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return null;

    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .maybeSingle();

    if (error) {
      console.error('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error);
      return null;
    }

    return data;
  },

  async getAllProfiles(): Promise<Profile[]> {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .order('created_at', { ascending: false });

    if (error) {
      console.error('è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥:', error);
      return [];
    }

    return Array.isArray(data) ? data : [];
  },

  async updateProfile(id: string, updates: Partial<Profile>): Promise<boolean> {
    const { error } = await supabase
      .from('profiles')
      .update(updates)
      .eq('id', id);

    if (error) {
      console.error('æ›´æ–°ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error);
      return false;
    }

    return true;
  }
};

export const itemApi = {
  async createItem(item: Omit<Item, 'id' | 'created_at' | 'updated_at'>): Promise<Item | null> {
    const { data, error } = await supabase
      .from('items')
      .insert([item])
      .select()
      .maybeSingle();

    if (error) {
      console.error('åˆ›å»ºæ¡ç›®å¤±è´¥:', error);
      return null;
    }

    return data;
  },

  async getItems(filters?: {
    type?: ItemType;
    status?: string;
    tag?: string;
  }): Promise<Item[]> {
    let query = supabase
      .from('items')
      .select('*')
      .is('archived_at', null);

    if (filters?.type) {
      query = query.eq('type', filters.type);
    }

    if (filters?.status) {
      query = query.eq('status', filters.status);
    }

    if (filters?.tag) {
      query = query.contains('tags', [filters.tag]);
    }

    const { data, error } = await query.order('created_at', { ascending: false });

    if (error) {
      console.error('è·å–æ¡ç›®åˆ—è¡¨å¤±è´¥:', error);
      return [];
    }

    return Array.isArray(data) ? data : [];
  },

  async getTodayItems(): Promise<Item[]> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    console.log('ğŸ“… ä»Šæ—¥è§†å›¾æŸ¥è¯¢æ¡ä»¶:', {
      today: today.toISOString(),
      tomorrow: tomorrow.toISOString(),
      todayLocal: today.toLocaleString('zh-CN'),
      tomorrowLocal: tomorrow.toLocaleString('zh-CN')
    });

    // æŸ¥è¯¢ä»Šå¤©æœ‰æˆªæ­¢æ—¥æœŸçš„ä»»åŠ¡å’Œäº‹ä»¶
    const { data: withDueDate, error: error1 } = await supabase
      .from('items')
      .select('*')
      .is('archived_at', null)
      .in('type', ['task', 'event'])
      .gte('due_date', today.toISOString())
      .lt('due_date', tomorrow.toISOString())
      .order('due_date', { ascending: true });

    if (error1) {
      console.error('è·å–ä»Šæ—¥æœ‰æˆªæ­¢æ—¥æœŸçš„æ¡ç›®å¤±è´¥:', error1);
    }

    // æŸ¥è¯¢ä»Šå¤©åˆ›å»ºä½†æ²¡æœ‰æˆªæ­¢æ—¥æœŸçš„ä»»åŠ¡å’Œäº‹ä»¶
    const { data: withoutDueDate, error: error2 } = await supabase
      .from('items')
      .select('*')
      .is('archived_at', null)
      .in('type', ['task', 'event'])
      .is('due_date', null)
      .gte('created_at', today.toISOString())
      .lt('created_at', tomorrow.toISOString())
      .order('created_at', { ascending: true });

    if (error2) {
      console.error('è·å–ä»Šæ—¥åˆ›å»ºæ— æˆªæ­¢æ—¥æœŸçš„æ¡ç›®å¤±è´¥:', error2);
    }

    // æŸ¥è¯¢è¿‡æœŸä½†æœªå®Œæˆçš„ä»»åŠ¡
    const { data: overdueItems, error: error3 } = await supabase
      .from('items')
      .select('*')
      .is('archived_at', null)
      .eq('type', 'task')
      .eq('status', 'pending')
      .lt('due_date', today.toISOString())
      .not('due_date', 'is', null)
      .order('due_date', { ascending: true });

    if (error3) {
      console.error('è·å–è¿‡æœŸä»»åŠ¡å¤±è´¥:', error3);
    }

    const allItems = [
      ...(Array.isArray(withDueDate) ? withDueDate : []),
      ...(Array.isArray(withoutDueDate) ? withoutDueDate : []),
      ...(Array.isArray(overdueItems) ? overdueItems : [])
    ];

    // å»é‡ï¼ˆä½¿ç”¨idï¼‰
    const uniqueItems = Array.from(
      new Map(allItems.map(item => [item.id, item])).values()
    );

    console.log('ğŸ“… ä»Šæ—¥è§†å›¾ç»“æœ:', {
      withDueDate: withDueDate?.length || 0,
      withoutDueDate: withoutDueDate?.length || 0,
      overdueItems: overdueItems?.length || 0,
      total: uniqueItems.length,
      items: uniqueItems.map(item => ({
        id: item.id,
        title: item.title,
        type: item.type,
        due_date: item.due_date,
        created_at: item.created_at
      }))
    });

    return uniqueItems;
  },

  async getUpcomingItems(): Promise<Item[]> {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);

    console.log('ğŸ“† å³å°†å‘ç”Ÿè§†å›¾æŸ¥è¯¢æ¡ä»¶:', {
      tomorrow: tomorrow.toISOString(),
      tomorrowLocal: tomorrow.toLocaleString('zh-CN')
    });

    const { data, error } = await supabase
      .from('items')
      .select('*')
      .is('archived_at', null)
      .in('type', ['task', 'event'])
      .gte('due_date', tomorrow.toISOString())
      .order('due_date', { ascending: true });

    if (error) {
      console.error('è·å–å³å°†å‘ç”Ÿæ¡ç›®å¤±è´¥:', error);
      return [];
    }

    const items = Array.isArray(data) ? data : [];
    
    console.log('ğŸ“† å³å°†å‘ç”Ÿè§†å›¾ç»“æœ:', {
      total: items.length,
      items: items.slice(0, 5).map(item => ({
        id: item.id,
        title: item.title,
        type: item.type,
        due_date: item.due_date
      }))
    });

    return items;
  },

  async getInboxItems(): Promise<Item[]> {
    console.log('ğŸ“¥ æ”¶ä»¶ç®±è§†å›¾æŸ¥è¯¢...');

    // æŸ¥è¯¢noteå’Œdataç±»å‹çš„æ¡ç›®
    const { data: noteData, error: error1 } = await supabase
      .from('items')
      .select('*')
      .is('archived_at', null)
      .in('type', ['note', 'data'])
      .order('created_at', { ascending: false });

    if (error1) {
      console.error('è·å–note/dataç±»å‹æ¡ç›®å¤±è´¥:', error1);
    }

    // æŸ¥è¯¢æ²¡æœ‰æˆªæ­¢æ—¥æœŸçš„taskå’Œeventï¼ˆè¿™äº›å¯èƒ½æ˜¯AIæœªèƒ½è¯†åˆ«æ—¶é—´çš„æ¡ç›®ï¼‰
    const { data: noDateItems, error: error2 } = await supabase
      .from('items')
      .select('*')
      .is('archived_at', null)
      .in('type', ['task', 'event'])
      .is('due_date', null)
      .order('created_at', { ascending: false });

    if (error2) {
      console.error('è·å–æ— æˆªæ­¢æ—¥æœŸçš„task/eventå¤±è´¥:', error2);
    }

    const allItems = [
      ...(Array.isArray(noteData) ? noteData : []),
      ...(Array.isArray(noDateItems) ? noDateItems : [])
    ];

    // æŒ‰åˆ›å»ºæ—¶é—´æ’åº
    allItems.sort((a, b) => 
      new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
    );

    console.log('ğŸ“¥ æ”¶ä»¶ç®±è§†å›¾ç»“æœ:', {
      noteData: noteData?.length || 0,
      noDateItems: noDateItems?.length || 0,
      total: allItems.length,
      items: allItems.slice(0, 5).map(item => ({
        id: item.id,
        title: item.title,
        type: item.type,
        due_date: item.due_date,
        created_at: item.created_at
      }))
    });

    return allItems;
  },

  async getAllTags(): Promise<string[]> {
    const { data, error } = await supabase
      .from('items')
      .select('tags')
      .is('archived_at', null);

    if (error) {
      console.error('è·å–æ ‡ç­¾åˆ—è¡¨å¤±è´¥:', error);
      return [];
    }

    if (!Array.isArray(data)) return [];

    const tagsSet = new Set<string>();
    data.forEach(item => {
      if (Array.isArray(item.tags)) {
        item.tags.forEach(tag => tagsSet.add(tag));
      }
    });

    return Array.from(tagsSet).sort();
  },

  async getTagStats(): Promise<TagStats[]> {
    const { data, error } = await supabase
      .from('items')
      .select('tags, created_at')
      .is('archived_at', null);

    if (error) {
      console.error('è·å–æ ‡ç­¾ç»Ÿè®¡å¤±è´¥:', error);
      return [];
    }

    if (!Array.isArray(data)) return [];

    const tagMap = new Map<string, { count: number; lastUsed: string }>();
    
    data.forEach(item => {
      if (Array.isArray(item.tags)) {
        item.tags.forEach(tag => {
          const existing = tagMap.get(tag);
          if (existing) {
            existing.count++;
            if (item.created_at > existing.lastUsed) {
              existing.lastUsed = item.created_at;
            }
          } else {
            tagMap.set(tag, {
              count: 1,
              lastUsed: item.created_at
            });
          }
        });
      }
    });

    const tagStats: TagStats[] = Array.from(tagMap.entries()).map(([tag, stats]) => ({
      tag,
      count: stats.count,
      lastUsed: stats.lastUsed
    }));

    return tagStats.sort((a, b) => b.count - a.count);
  },

  async updateItem(id: string, updates: Partial<Item>): Promise<boolean> {
    const { error } = await supabase
      .from('items')
      .update(updates)
      .eq('id', id);

    if (error) {
      console.error('æ›´æ–°æ¡ç›®å¤±è´¥:', error);
      return false;
    }

    return true;
  },

  async deleteItem(id: string): Promise<boolean> {
    const { error } = await supabase
      .from('items')
      .delete()
      .eq('id', id);

    if (error) {
      console.error('åˆ é™¤æ¡ç›®å¤±è´¥:', error);
      return false;
    }

    return true;
  },

  async archiveItem(id: string): Promise<boolean> {
    const { error } = await supabase
      .from('items')
      .update({ archived_at: new Date().toISOString() })
      .eq('id', id);

    if (error) {
      console.error('å½’æ¡£æ¡ç›®å¤±è´¥:', error);
      return false;
    }

    return true;
  },

  async searchItems(query: string): Promise<Item[]> {
    const { data, error } = await supabase
      .from('items')
      .select('*')
      .is('archived_at', null)
      .or(`title.ilike.%${query}%,description.ilike.%${query}%,raw_text.ilike.%${query}%,url_summary.ilike.%${query}%`)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('æœç´¢æ¡ç›®å¤±è´¥:', error);
      return [];
    }

    return Array.isArray(data) ? data : [];
  },

  async getURLItems(): Promise<Item[]> {
    console.log('ğŸ“ é“¾æ¥åº“è§†å›¾æŸ¥è¯¢...');

    const { data, error } = await supabase
      .from('items')
      .select('*')
      .is('archived_at', null)
      .eq('type', 'url')
      .order('created_at', { ascending: false });

    if (error) {
      console.error('è·å–é“¾æ¥åº“æ¡ç›®å¤±è´¥:', error);
      return [];
    }

    const items = Array.isArray(data) ? data : [];

    console.log('ğŸ“ é“¾æ¥åº“è§†å›¾ç»“æœ:', {
      total: items.length,
      items: items.slice(0, 5).map(item => ({
        id: item.id,
        title: item.url_title,
        url: item.url,
        created_at: item.created_at
      }))
    });

    return items;
  },

  async getItemsByTag(tag: string): Promise<Item[]> {
    console.log('ğŸ·ï¸ æŒ‰æ ‡ç­¾æŸ¥è¯¢æ¡ç›®:', tag);

    const { data, error } = await supabase
      .from('items')
      .select('*')
      .is('archived_at', null)
      .contains('tags', [tag])
      .order('created_at', { ascending: false });

    if (error) {
      console.error('æŒ‰æ ‡ç­¾æŸ¥è¯¢æ¡ç›®å¤±è´¥:', error);
      return [];
    }

    const items = Array.isArray(data) ? data : [];

    console.log('ğŸ·ï¸ æ ‡ç­¾æŸ¥è¯¢ç»“æœ:', {
      tag,
      total: items.length
    });

    return items;
  },

  async getAllItemsHistory(): Promise<Item[]> {
    console.log('ğŸ“œ å†å²è®°å½•æŸ¥è¯¢...');

    const { data, error } = await supabase
      .from('items')
      .select('*')
      .is('archived_at', null)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('è·å–å†å²è®°å½•å¤±è´¥:', error);
      return [];
    }

    const items = Array.isArray(data) ? data : [];

    console.log('ğŸ“œ å†å²è®°å½•ç»“æœ:', {
      total: items.length
    });

    return items;
  },

  async queryItems(intent: any): Promise<Item[]> {
    console.log('ğŸ” æ™ºèƒ½æŸ¥è¯¢:', intent);

    let query = supabase
      .from('items')
      .select('*')
      .is('archived_at', null);

    // æŒ‰ç±»å‹ç­›é€‰
    if (intent.itemType) {
      query = query.eq('type', intent.itemType);
    }

    // æŒ‰æ—¶é—´èŒƒå›´ç­›é€‰
    if (intent.timeRange) {
      if (intent.queryType === 'today' || intent.queryType === 'upcoming') {
        // æŸ¥è¯¢due_dateåœ¨èŒƒå›´å†…çš„
        query = query
          .gte('due_date', intent.timeRange.start)
          .lte('due_date', intent.timeRange.end);
      } else {
        // æŸ¥è¯¢created_atåœ¨èŒƒå›´å†…çš„
        query = query
          .gte('created_at', intent.timeRange.start)
          .lte('created_at', intent.timeRange.end);
      }
    }

    // æŒ‰æ ‡ç­¾ç­›é€‰
    if (intent.tags && intent.tags.length > 0) {
      query = query.overlaps('tags', intent.tags);
    }

    // æŒ‰å…³é”®è¯æœç´¢
    if (intent.keywords && intent.keywords.length > 0) {
      const keyword = intent.keywords[0];
      query = query.or(
        `title.ilike.%${keyword}%,description.ilike.%${keyword}%,raw_text.ilike.%${keyword}%,url_summary.ilike.%${keyword}%`
      );
    }

    const { data, error } = await query.order('created_at', { ascending: false });

    if (error) {
      console.error('æ™ºèƒ½æŸ¥è¯¢å¤±è´¥:', error);
      return [];
    }

    const items = Array.isArray(data) ? data : [];

    console.log('ğŸ” æŸ¥è¯¢ç»“æœ:', {
      total: items.length,
      intent: intent.queryType
    });

    return items;
  }
};
